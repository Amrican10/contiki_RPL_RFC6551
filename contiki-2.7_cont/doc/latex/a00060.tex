\hypertarget{a00060}{\subsection{\-The u\-I\-P \-T\-C\-P/\-I\-P stack}
\label{a00060}\index{\-The u\-I\-P T\-C\-P/\-I\-P stack@{\-The u\-I\-P T\-C\-P/\-I\-P stack}}
}


\-The u\-I\-P \-T\-C\-P/\-I\-P stack provides \-Internet communication abilities to \-Contiki.  


\subsubsection*{\-Modules}
\begin{DoxyCompactItemize}
\item 
\hyperlink{a00056}{6\-Lo\-W\-P\-A\-N implementation}
\begin{DoxyCompactList}\small\item\em 6lowpan is a \-Working \-Group in \-I\-E\-T\-F which defines the use of \-I\-Pv6 on \-I\-E\-E\-E 802.\-15.\-4 links. \end{DoxyCompactList}\item 
\hyperlink{a00061}{u\-I\-P I\-Pv6 specific features}
\begin{DoxyCompactList}\small\item\em \-The u\-I\-P \-I\-Pv6 stack provides new \-Internet communication abilities to \-Contiki. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\-The u\-I\-P \-T\-C\-P/\-I\-P stack provides \-Internet communication abilities to \-Contiki. \hypertarget{a00060_uip-introduction}{}\subsubsection{u\-I\-P introduction}\label{a00060_uip-introduction}
\-The u\-I\-P \-T\-C\-P/\-I\-P stack is intended to make it possible to communicate using the \-T\-C\-P/\-I\-P protocol suite even on small 8-\/bit micro-\/controllers. \-Despite being small and simple, u\-I\-P do not require their peers to have complex, full-\/size stacks, but can communicate with peers running a similarly light-\/weight stack. \-The code size is on the order of a few kilobytes and \-R\-A\-M usage can be configured to be as low as a few hundred bytes.

u\-I\-P can be found at the u\-I\-P web page\-: \href{http://www.sics.se/~adam/uip/}{\tt http\-://www.\-sics.\-se/$\sim$adam/uip/}

\begin{DoxySeeAlso}{\-See also}
tcpip 

\hyperlink{a00061}{u\-I\-P \-I\-Pv6 specific features} and \hyperlink{a00056}{6\-Lo\-W\-P\-A\-N implementation} 

u\-I\-P \-Compile-\/time configuration options 

u\-I\-P \-Run-\/time configuration functions 

u\-I\-P initialization functions 

u\-I\-P device driver interface and u\-I\-P variables used by device drivers 

u\-I\-P functions called from application programs (see below) and the protosockets \-A\-P\-I and their underlying \hyperlink{a00052}{protothreads}
\end{DoxySeeAlso}
\hypertarget{a00060_uIPIntroduction}{}\subsubsection{\-Introduction}\label{a00060_uIPIntroduction}
\-With the success of the \-Internet, the \-T\-C\-P/\-I\-P protocol suite has become a global standard for communication. \-T\-C\-P/\-I\-P is the underlying protocol used for web page transfers, e-\/mail transmissions, file transfers, and peer-\/to-\/peer networking over the \-Internet. \-For embedded systems, being able to run native \-T\-C\-P/\-I\-P makes it possible to connect the system directly to an intranet or even the global \-Internet. \-Embedded devices with full \-T\-C\-P/\-I\-P support will be first-\/class network citizens, thus being able to fully communicate with other hosts in the network.

\-Traditional \-T\-C\-P/\-I\-P implementations have required far too much resources both in terms of code size and memory usage to be useful in small 8 or 16-\/bit systems. \-Code size of a few hundred kilobytes and \-R\-A\-M requirements of several hundreds of kilobytes have made it impossible to fit the full \-T\-C\-P/\-I\-P stack into systems with a few tens of kilobytes of \-R\-A\-M and room for less than 100 kilobytes of code.

\-The u\-I\-P implementation is designed to have only the absolute minimal set of features needed for a full \-T\-C\-P/\-I\-P stack. \-It can only handle a single network interface and contains the \-I\-P, \-I\-C\-M\-P, \-U\-D\-P and \-T\-C\-P protocols. u\-I\-P is written in the \-C programming language.

\-Many other \-T\-C\-P/\-I\-P implementations for small systems assume that the embedded device always will communicate with a full-\/scale \-T\-C\-P/\-I\-P implementation running on a workstation-\/class machine. \-Under this assumption, it is possible to remove certain \-T\-C\-P/\-I\-P mechanisms that are very rarely used in such situations. \-Many of those mechanisms are essential, however, if the embedded device is to communicate with another equally limited device, e.\-g., when running distributed peer-\/to-\/peer services and protocols. u\-I\-P is designed to be \-R\-F\-C compliant in order to let the embedded devices to act as first-\/class network citizens. \-The u\-I\-P \-T\-C\-P/\-I\-P implementation that is not tailored for any specific application.\hypertarget{a00060_uip-tcpip}{}\subsubsection{\-T\-C\-P/\-I\-P Communication}\label{a00060_uip-tcpip}
\-The full \-T\-C\-P/\-I\-P suite consists of numerous protocols, ranging from low level protocols such as \-A\-R\-P which translates \-I\-P addresses to \-M\-A\-C addresses, to application level protocols such as \-S\-M\-T\-P that is used to transfer e-\/mail. \-The u\-I\-P is mostly concerned with the \-T\-C\-P and \-I\-P protocols and upper layer protocols will be referred to as \char`\"{}the
application\char`\"{}. \-Lower layer protocols are often implemented in hardware or firmware and will be referred to as \char`\"{}the network device\char`\"{} that are controlled by the network device driver.

\-T\-C\-P provides a reliable byte stream to the upper layer protocols. \-It breaks the byte stream into appropriately sized segments and each segment is sent in its own \-I\-P packet. \-The \-I\-P packets are sent out on the network by the network device driver. \-If the destination is not on the physically connected network, the \-I\-P packet is forwarded onto another network by a router that is situated between the two networks. \-If the maximum packet size of the other network is smaller than the size of the \-I\-P packet, the packet is fragmented into smaller packets by the router. \-If possible, the size of the \-T\-C\-P segments are chosen so that fragmentation is minimized. \-The final recipient of the packet will have to reassemble any fragmented \-I\-P packets before they can be passed to higher layers.

\-The formal requirements for the protocols in the \-T\-C\-P/\-I\-P stack is specified in a number of \-R\-F\-C documents published by the \-Internet \-Engineering \-Task \-Force, \-I\-E\-T\-F. \-Each of the protocols in the stack is defined in one more \-R\-F\-C documents and \-R\-F\-C1122 collects all requirements and updates the previous \-R\-F\-Cs.

\-The \-R\-F\-C1122 requirements can be divided into two categories; those that deal with the host to host communication and those that deal with communication between the application and the networking stack. \-An example of the first kind is \char`\"{}\-A T\-C\-P M\-U\-S\-T be able to receive a T\-C\-P
option in any segment\char`\"{} and an example of the second kind is "\-There \-M\-U\-S\-T be a mechanism for reporting soft \-T\-C\-P error conditions to the application." \-A \-T\-C\-P/\-I\-P implementation that violates requirements of the first kind may not be able to communicate with other \-T\-C\-P/\-I\-P implementations and may even lead to network failures. \-Violation of the second kind of requirements will only affect the communication within the system and will not affect host-\/to-\/host communication.

\-In u\-I\-P, all \-R\-F\-C requirements that affect host-\/to-\/host communication are implemented. \-However, in order to reduce code size, we have removed certain mechanisms in the interface between the application and the stack, such as the soft error reporting mechanism and dynamically configurable type-\/of-\/service bits for \-T\-C\-P connections. \-Since there are only very few applications that make use of those features they can be removed without loss of generality.\hypertarget{a00060_mainloop}{}\subsubsection{\-Main Control Loop}\label{a00060_mainloop}
\-The u\-I\-P stack can be run either as a task in a multitasking system, or as the main program in a singletasking system. \-In both cases, the main control loop does two things repeatedly\-:


\begin{DoxyItemize}
\item \-Check if a packet has arrived from the network.
\item \-Check if a periodic timeout has occurred.
\end{DoxyItemize}

\-If a packet has arrived, the input handler function, uip\-\_\-input(), should be invoked by the main control loop. \-The input handler function will never block, but will return at once. \-When it returns, the stack or the application for which the incoming packet was intended may have produced one or more reply packets which should be sent out. \-If so, the network device driver should be called to send out these packets.

\-Periodic timeouts are used to drive \-T\-C\-P mechanisms that depend on timers, such as delayed acknowledgments, retransmissions and round-\/trip time estimations. \-When the main control loop infers that the periodic timer should fire, it should invoke the timer handler function uip\-\_\-periodic(). \-Because the \-T\-C\-P/\-I\-P stack may perform retransmissions when dealing with a timer event, the network device driver should called to send out the packets that may have been produced.\hypertarget{a00060_arch}{}\subsubsection{\-Architecture Specific Functions}\label{a00060_arch}
u\-I\-P requires a few functions to be implemented specifically for the architecture on which u\-I\-P is intended to run. \-These functions should be hand-\/tuned for the particular architecture, but generic \-C implementations are given as part of the u\-I\-P distribution.\hypertarget{a00060_checksums}{}\paragraph{\-Checksum Calculation}\label{a00060_checksums}
\-The \-T\-C\-P and \-I\-P protocols implement a checksum that covers the data and header portions of the \-T\-C\-P and \-I\-P packets. \-Since the calculation of this checksum is made over all bytes in every packet being sent and received it is important that the function that calculates the checksum is efficient. \-Most often, this means that the checksum calculation must be fine-\/tuned for the particular architecture on which the u\-I\-P stack runs.

\-While u\-I\-P includes a generic checksum function, it also leaves it open for an architecture specific implementation of the two functions uip\-\_\-ipchksum() and uip\-\_\-tcpchksum(). \-The checksum calculations in those functions can be written in highly optimized assembler rather than generic \-C code.\hypertarget{a00060_longarith}{}\paragraph{32-\/bit Arithmetic}\label{a00060_longarith}
\-The \-T\-C\-P protocol uses 32-\/bit sequence numbers, and a \-T\-C\-P implementation will have to do a number of 32-\/bit additions as part of the normal protocol processing. \-Since 32-\/bit arithmetic is not natively available on many of the platforms for which u\-I\-P is intended, u\-I\-P leaves the 32-\/bit additions to be implemented by the architecture specific module and does not make use of any 32-\/bit arithmetic in the main code base.

\-While u\-I\-P implements a generic 32-\/bit addition, there is support for having an architecture specific implementation of the uip\-\_\-add32() function.\hypertarget{a00060_memory}{}\subsubsection{\-Memory Management}\label{a00060_memory}
\-In the architectures for which u\-I\-P is intended, \-R\-A\-M is the most scarce resource. \-With only a few kilobytes of \-R\-A\-M available for the \-T\-C\-P/\-I\-P stack to use, mechanisms used in traditional \-T\-C\-P/\-I\-P cannot be directly applied.

\-The u\-I\-P stack does not use explicit dynamic memory allocation. \-Instead, it uses a single global buffer for holding packets and has a fixed table for holding connection state. \-The global packet buffer is large enough to contain one packet of maximum size. \-When a packet arrives from the network, the device driver places it in the global buffer and calls the \-T\-C\-P/\-I\-P stack. \-If the packet contains data, the \-T\-C\-P/\-I\-P stack will notify the corresponding application. \-Because the data in the buffer will be overwritten by the next incoming packet, the application will either have to act immediately on the data or copy the data into a secondary buffer for later processing. \-The packet buffer will not be overwritten by new packets before the application has processed the data. \-Packets that arrive when the application is processing the data must be queued, either by the network device or by the device driver. \-Most single-\/chip \-Ethernet controllers have on-\/chip buffers that are large enough to contain at least 4 maximum sized \-Ethernet frames. \-Devices that are handled by the processor, such as \-R\-S-\/232 ports, can copy incoming bytes to a separate buffer during application processing. \-If the buffers are full, the incoming packet is dropped. \-This will cause performance degradation, but only when multiple connections are running in parallel. \-This is because u\-I\-P advertises a very small receiver window, which means that only a single \-T\-C\-P segment will be in the network per connection.

\-In u\-I\-P, the same global packet buffer that is used for incoming packets is also used for the \-T\-C\-P/\-I\-P headers of outgoing data. \-If the application sends dynamic data, it may use the parts of the global packet buffer that are not used for headers as a temporary storage buffer. \-To send the data, the application passes a pointer to the data as well as the length of the data to the stack. \-The \-T\-C\-P/\-I\-P headers are written into the global buffer and once the headers have been produced, the device driver sends the headers and the application data out on the network. \-The data is not queued for retransmissions. \-Instead, the application will have to reproduce the data if a retransmission is necessary.

\-The total amount of memory usage for u\-I\-P depends heavily on the applications of the particular device in which the implementations are to be run. \-The memory configuration determines both the amount of traffic the system should be able to handle and the maximum amount of simultaneous connections. \-A device that will be sending large e-\/mails while at the same time running a web server with highly dynamic web pages and multiple simultaneous clients, will require more \-R\-A\-M than a simple \-Telnet server. \-It is possible to run the u\-I\-P implementation with as little as 200 bytes of \-R\-A\-M, but such a configuration will provide extremely low throughput and will only allow a small number of simultaneous connections.\hypertarget{a00060_api}{}\subsubsection{\-Application Program Interface (\-A\-P\-I)}\label{a00060_api}
\-The \-Application \-Program \-Interface (\-A\-P\-I) defines the way the application program interacts with the \-T\-C\-P/\-I\-P stack. \-The most commonly used \-A\-P\-I for \-T\-C\-P/\-I\-P is the \-B\-S\-D socket \-A\-P\-I which is used in most \-Unix systems and has heavily influenced the \-Microsoft \-Windows \-Win\-Sock \-A\-P\-I. \-Because the socket \-A\-P\-I uses stop-\/and-\/wait semantics, it requires support from an underlying multitasking operating system. \-Since the overhead of task management, context switching and allocation of stack space for the tasks might be too high in the intended u\-I\-P target architectures, the \-B\-S\-D socket interface is not suitable for our purposes.

u\-I\-P provides two \-A\-P\-Is to programmers\-: protosockets, a \-B\-S\-D socket-\/like \-A\-P\-I without the overhead of full multi-\/threading, and a \char`\"{}raw\char`\"{} event-\/based \-A\-P\-I that is nore low-\/level than protosockets but uses less memory.

\begin{DoxySeeAlso}{\-See also}
psock 

\hyperlink{a00052}{\-Protothreads}
\end{DoxySeeAlso}
\hypertarget{a00060_rawapi}{}\paragraph{\-The u\-I\-P raw A\-P\-I}\label{a00060_rawapi}
\-The \char`\"{}raw\char`\"{} u\-I\-P \-A\-P\-I uses an event driven interface where the application is invoked in response to certain events. \-An application running on top of u\-I\-P is implemented as a \-C function that is called by u\-I\-P in response to certain events. u\-I\-P calls the application when data is received, when data has been successfully delivered to the other end of the connection, when a new connection has been set up, or when data has to be retransmitted. \-The application is also periodically polled for new data. \-The application program provides only one callback function; it is up to the application to deal with mapping different network services to different ports and connections. \-Because the application is able to act on incoming data and connection requests as soon as the \-T\-C\-P/\-I\-P stack receives the packet, low response times can be achieved even in low-\/end systems.

u\-I\-P is different from other \-T\-C\-P/\-I\-P stacks in that it requires help from the application when doing retransmissions. \-Other \-T\-C\-P/\-I\-P stacks buffer the transmitted data in memory until the data is known to be successfully delivered to the remote end of the connection. \-If the data needs to be retransmitted, the stack takes care of the retransmission without notifying the application. \-With this approach, the data has to be buffered in memory while waiting for an acknowledgment even if the application might be able to quickly regenerate the data if a retransmission has to be made.

\-In order to reduce memory usage, u\-I\-P utilizes the fact that the application may be able to regenerate sent data and lets the application take part in retransmissions. u\-I\-P does not keep track of packet contents after they have been sent by the device driver, and u\-I\-P requires that the application takes an active part in performing the retransmission. \-When u\-I\-P decides that a segment should be retransmitted, it calls the application with a flag set indicating that a retransmission is required. \-The application checks the retransmission flag and produces the same data that was previously sent. \-From the application's standpoint, performing a retransmission is not different from how the data originally was sent. \-Therefore the application can be written in such a way that the same code is used both for sending data and retransmitting data. \-Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. \-Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.\hypertarget{a00060_appevents}{}\subparagraph{\-Application Events}\label{a00060_appevents}
\-The application must be implemented as a \-C function, \-U\-I\-P\-\_\-\-A\-P\-P\-C\-A\-L\-L(), that u\-I\-P calls whenever an event occurs. \-Each event has a corresponding test function that is used to distinguish between different events. \-The functions are implemented as \-C macros that will evaluate to either zero or non-\/zero. \-Note that certain events can happen in conjunction with each other (i.\-e., new data can arrive at the same time as data is acknowledged).\hypertarget{a00060_connstate}{}\subparagraph{\-The Connection Pointer}\label{a00060_connstate}
\-When the application is called by u\-I\-P, the global variable uip\-\_\-conn is set to point to the uip\-\_\-conn structure for the connection that currently is handled, and is called the \char`\"{}current connection\char`\"{}. \-The fields in the uip\-\_\-conn structure for the current connection can be used, e.\-g., to distinguish between different services, or to check to which \-I\-P address the connection is connected. \-One typical use would be to inspect the uip\-\_\-conn-\/$>$lport (the local \-T\-C\-P port number) to decide which service the connection should provide. \-For instance, an application might decide to act as an \-H\-T\-T\-P server if the value of uip\-\_\-conn-\/$>$lport is equal to 80 and act as a \-T\-E\-L\-N\-E\-T server if the value is 23.\hypertarget{a00060_recvdata}{}\subparagraph{\-Receiving Data}\label{a00060_recvdata}
\-If the u\-I\-P test function uip\-\_\-newdata() is non-\/zero, the remote host of the connection has sent new data. \-The uip\-\_\-appdata pointer point to the actual data. \-The size of the data is obtained through the u\-I\-P function uip\-\_\-datalen(). \-The data is not buffered by u\-I\-P, but will be overwritten after the application function returns, and the application will therefor have to either act directly on the incoming data, or by itself copy the incoming data into a buffer for later processing.\hypertarget{a00060_senddata}{}\subparagraph{\-Sending Data}\label{a00060_senddata}
\-When sending data, u\-I\-P adjusts the length of the data sent by the application according to the available buffer space and the current \-T\-C\-P window advertised by the receiver. \-The amount of buffer space is dictated by the memory configuration. \-It is therefore possible that all data sent from the application does not arrive at the receiver, and the application may use the uip\-\_\-mss() function to see how much data that actually will be sent by the stack.

\-The application sends data by using the u\-I\-P function uip\-\_\-send(). \-The uip\-\_\-send() function takes two arguments; a pointer to the data to be sent and the length of the data. \-If the application needs \-R\-A\-M space for producing the actual data that should be sent, the packet buffer (pointed to by the uip\-\_\-appdata pointer) can be used for this purpose.

\-The application can send only one chunk of data at a time on a connection and it is not possible to call uip\-\_\-send() more than once per application invocation; only the data from the last call will be sent.\hypertarget{a00060_rexmitdata}{}\subparagraph{\-Retransmitting Data}\label{a00060_rexmitdata}
\-Retransmissions are driven by the periodic \-T\-C\-P timer. \-Every time the periodic timer is invoked, the retransmission timer for each connection is decremented. \-If the timer reaches zero, a retransmission should be made. \-As u\-I\-P does not keep track of packet contents after they have been sent by the device driver, u\-I\-P requires that the application takes an active part in performing the retransmission. \-When u\-I\-P decides that a segment should be retransmitted, the application function is called with the uip\-\_\-rexmit() flag set, indicating that a retransmission is required.

\-The application must check the uip\-\_\-rexmit() flag and produce the same data that was previously sent. \-From the application's standpoint, performing a retransmission is not different from how the data originally was sent. \-Therefor, the application can be written in such a way that the same code is used both for sending data and retransmitting data. \-Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. \-Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.\hypertarget{a00060_closing}{}\subparagraph{\-Closing Connections}\label{a00060_closing}
\-The application closes the current connection by calling the uip\-\_\-close() during an application call. \-This will cause the connection to be cleanly closed. \-In order to indicate a fatal error, the application might want to abort the connection and does so by calling the uip\-\_\-abort() function.

\-If the connection has been closed by the remote end, the test function uip\-\_\-closed() is true. \-The application may then do any necessary cleanups.\hypertarget{a00060_errors}{}\subparagraph{\-Reporting Errors}\label{a00060_errors}
\-There are two fatal errors that can happen to a connection, either that the connection was aborted by the remote host, or that the connection retransmitted the last data too many times and has been aborted. u\-I\-P reports this by calling the application function. \-The application can use the two test functions uip\-\_\-aborted() and uip\-\_\-timedout() to test for those error conditions.\hypertarget{a00060_polling}{}\subparagraph{\-Polling}\label{a00060_polling}
\-When a connection is idle, u\-I\-P polls the application every time the periodic timer fires. \-The application uses the test function uip\-\_\-poll() to check if it is being polled by u\-I\-P.

\-The polling event has two purposes. \-The first is to let the application periodically know that a connection is idle, which allows the application to close connections that have been idle for too long. \-The other purpose is to let the application send new data that has been produced. \-The application can only send data when invoked by u\-I\-P, and therefore the poll event is the only way to send data on an otherwise idle connection.\hypertarget{a00060_listen}{}\subparagraph{\-Listening Ports}\label{a00060_listen}
u\-I\-P maintains a list of listening \-T\-C\-P ports. \-A new port is opened for listening with the uip\-\_\-listen() function. \-When a connection request arrives on a listening port, u\-I\-P creates a new connection and calls the application function. \-The test function uip\-\_\-connected() is true if the application was invoked because a new connection was created.

\-The application can check the lport field in the uip\-\_\-conn structure to check to which port the new connection was connected.\hypertarget{a00060_connect}{}\subparagraph{\-Opening Connections}\label{a00060_connect}
\-New connections can be opened from within u\-I\-P by the function uip\-\_\-connect(). \-This function allocates a new connection and sets a flag in the connection state which will open a \-T\-C\-P connection to the specified \-I\-P address and port the next time the connection is polled by u\-I\-P. \-The uip\-\_\-connect() function returns a pointer to the uip\-\_\-conn structure for the new connection. \-If there are no free connection slots, the function returns \-N\-U\-L\-L.

\-The function uip\-\_\-ipaddr() may be used to pack an \-I\-P address into the two element 16-\/bit array used by u\-I\-P to represent \-I\-P addresses.

\-Two examples of usage are shown below. \-The first example shows how to open a connection to \-T\-C\-P port 8080 of the remote end of the current connection. \-If there are not enough \-T\-C\-P connection slots to allow a new connection to be opened, the uip\-\_\-connect() function returns \-N\-U\-L\-L and the current connection is aborted by uip\-\_\-abort().


\begin{DoxyCode}
void connect_example1_app(void) {
   if(uip_connect(uip_conn->ripaddr, HTONS(8080)) == NULL) {
      uip_abort();
   }
}   
\end{DoxyCode}


\-The second example shows how to open a new connection to a specific \-I\-P address. \-No error checks are made in this example.


\begin{DoxyCode}
void connect_example2(void) {
   uip_addr_t ipaddr;

   uip_ipaddr(ipaddr, 192,168,0,1);
   uip_connect(ipaddr, HTONS(8080));
}
\end{DoxyCode}
\hypertarget{a00060_examples}{}\subsubsection{\-Examples}\label{a00060_examples}
\-This section presents a number of very simple u\-I\-P applications. \-The u\-I\-P code distribution contains several more complex applications.\hypertarget{a00060_example1}{}\paragraph{\-A Very Simple Application}\label{a00060_example1}
\-This first example shows a very simple application. \-The application listens for incoming connections on port 1234. \-When a connection has been established, the application replies to all data sent to it by saying \char`\"{}ok\char`\"{}

\-The implementation of this application is shown below. \-The application is initialized with the function called example1\-\_\-init() and the u\-I\-P callback function is called example1\-\_\-app(). \-For this application, the configuration variable \-U\-I\-P\-\_\-\-A\-P\-P\-C\-A\-L\-L should be defined to be example1\-\_\-app().


\begin{DoxyCode}
void example1_init(void) {
   uip_listen(HTONS(1234));
}

void example1_app(void) {
   if(uip_newdata() || uip_rexmit()) {
      uip_send("ok\n", 3);
   }
}
\end{DoxyCode}


\-The initialization function calls the u\-I\-P function uip\-\_\-listen() to register a listening port. \-The actual application function example1\-\_\-app() uses the test functions uip\-\_\-newdata() and uip\-\_\-rexmit() to determine why it was called. \-If the application was called because the remote end has sent it data, it responds with an \char`\"{}ok\char`\"{}. \-If the application function was called because data was lost in the network and has to be retransmitted, it also sends an \char`\"{}ok\char`\"{}. \-Note that this example actually shows a complete u\-I\-P application. \-It is not required for an application to deal with all types of events such as uip\-\_\-connected() or uip\-\_\-timedout().\hypertarget{a00060_example2}{}\paragraph{\-A More Advanced Application}\label{a00060_example2}
\-This second example is slightly more advanced than the previous one, and shows how the application state field in the uip\-\_\-conn structure is used.

\-This application is similar to the first application in that it listens to a port for incoming connections and responds to data sent to it with a single \char`\"{}ok\char`\"{}. \-The big difference is that this application prints out a welcoming \char`\"{}\-Welcome!\char`\"{} message when the connection has been established.

\-This seemingly small change of operation makes a big difference in how the application is implemented. \-The reason for the increase in complexity is that if data should be lost in the network, the application must know what data to retransmit. \-If the \char`\"{}\-Welcome!\char`\"{} message was lost, the application must retransmit the welcome and if one of the \char`\"{}ok\char`\"{} messages is lost, the application must send a new \char`\"{}ok\char`\"{}.

\-The application knows that as long as the \char`\"{}\-Welcome!\char`\"{} message has not been acknowledged by the remote host, it might have been dropped in the network. \-But once the remote host has sent an acknowledgment back, the application can be sure that the welcome has been received and knows that any lost data must be an \char`\"{}ok\char`\"{} message. \-Thus the application can be in either of two states\-: either in the \-W\-E\-L\-C\-O\-M\-E-\/\-S\-E\-N\-T state where the \char`\"{}\-Welcome!\char`\"{} has been sent but not acknowledged, or in the \-W\-E\-L\-C\-O\-M\-E-\/\-A\-C\-K\-E\-D state where the \char`\"{}\-Welcome!\char`\"{} has been acknowledged.

\-When a remote host connects to the application, the application sends the \char`\"{}\-Welcome!\char`\"{} message and sets it's state to \-W\-E\-L\-C\-O\-M\-E-\/\-S\-E\-N\-T. \-When the welcome message is acknowledged, the application moves to the \-W\-E\-L\-C\-O\-M\-E-\/\-A\-C\-K\-E\-D state. \-If the application receives any new data from the remote host, it responds by sending an \char`\"{}ok\char`\"{} back.

\-If the application is requested to retransmit the last message, it looks at in which state the application is. \-If the application is in the \-W\-E\-L\-C\-O\-M\-E-\/\-S\-E\-N\-T state, it sends a \char`\"{}\-Welcome!\char`\"{} message since it knows that the previous welcome message hasn't been acknowledged. \-If the application is in the \-W\-E\-L\-C\-O\-M\-E-\/\-A\-C\-K\-E\-D state, it knows that the last message was an \char`\"{}ok\char`\"{} message and sends such a message.

\-The implementation of this application is seen below. \-This configuration settings for the application is follows after its implementation.


\begin{DoxyCode}
struct example2_state {
   enum {WELCOME_SENT, WELCOME_ACKED} state;
};

void example2_init(void) {
   uip_listen(HTONS(2345));
}

void example2_app(void) {
   struct example2_state *s;

   s = (struct example2_state *)uip_conn->appstate;
   
   if(uip_connected()) {
      s->state = WELCOME_SENT;
      uip_send("Welcome!\n", 9);
      return;
   } 

   if(uip_acked() && s->state == WELCOME_SENT) {
      s->state = WELCOME_ACKED;
   }

   if(uip_newdata()) {
      uip_send("ok\n", 3);
   }

   if(uip_rexmit()) {
      switch(s->state) {
      case WELCOME_SENT:
         uip_send("Welcome!\n", 9);
         break;
      case WELCOME_ACKED:
         uip_send("ok\n", 3);
         break;
      }
   }
}
\end{DoxyCode}


\-The configuration for the application\-:


\begin{DoxyCode}
#define UIP_APPCALL       example2_app
#define UIP_APPSTATE_SIZE sizeof(struct example2_state)
\end{DoxyCode}
\hypertarget{a00060_example3}{}\paragraph{\-Differentiating Between Applications}\label{a00060_example3}
\-If the system should run multiple applications, one technique to differentiate between them is to use the \-T\-C\-P port number of either the remote end or the local end of the connection. \-The example below shows how the two examples above can be combined into one application.


\begin{DoxyCode}
void example3_init(void) {
   example1_init();
   example2_init();   
}

void example3_app(void) {
   switch(uip_conn->lport) {
   case HTONS(1234):
      example1_app();
      break;
   case HTONS(2345):
      example2_app();
      break;
   }
}
\end{DoxyCode}
\hypertarget{a00060_example4}{}\paragraph{\-Utilizing T\-C\-P Flow Control}\label{a00060_example4}
\-This example shows a simple application that connects to a host, sends an \-H\-T\-T\-P request for a file and downloads it to a slow device such a disk drive. \-This shows how to use the flow control functions of u\-I\-P.


\begin{DoxyCode}
void example4_init(void) {
   uip_ipaddr_t ipaddr;
   uip_ipaddr(ipaddr, 192,168,0,1);
   uip_connect(ipaddr, HTONS(80));
}

void example4_app(void) {
   if(uip_connected() || uip_rexmit()) {
      uip_send("GET /file HTTP/1.0\r\nServer:192.186.0.1\r\n\r\n",
               48);
      return;
   }

   if(uip_newdata()) {
      device_enqueue(uip_appdata, uip_datalen());
      if(device_queue_full()) {
         uip_stop();
      }
   }

   if(uip_poll() && uip_stopped()) {
      if(!device_queue_full()) {
         uip_restart();
      }
   }
}
\end{DoxyCode}


\-When the connection has been established, an \-H\-T\-T\-P request is sent to the server. \-Since this is the only data that is sent, the application knows that if it needs to retransmit any data, it is that request that should be retransmitted. \-It is therefore possible to combine these two events as is done in the example.

\-When the application receives new data from the remote host, it sends this data to the device by using the function device\-\_\-enqueue(). \-It is important to note that this example assumes that this function copies the data into its own buffers. \-The data in the uip\-\_\-appdata buffer will be overwritten by the next incoming packet.

\-If the device's queue is full, the application stops the data from the remote host by calling the u\-I\-P function uip\-\_\-stop(). \-The application can then be sure that it will not receive any new data until uip\-\_\-restart() is called. \-The application polling event is used to check if the device's queue is no longer full and if so, the data flow is restarted with uip\-\_\-restart().\hypertarget{a00060_example5}{}\paragraph{\-A Simple Web Server}\label{a00060_example5}
\-This example shows a very simple file server application that listens to two ports and uses the port number to determine which file to send. \-If the files are properly formatted, this simple application can be used as a web server with static pages. \-The implementation follows.


\begin{DoxyCode}
struct example5_state {
   char *dataptr;
   unsigned int dataleft;
};

void example5_init(void) {
   uip_listen(HTONS(80));
   uip_listen(HTONS(81));
}

void example5_app(void) {
   struct example5_state *s;
   s = (struct example5_state)uip_conn->appstate;
   
   if(uip_connected()) {
      switch(uip_conn->lport) {
      case HTONS(80):
         s->dataptr = data_port_80;
         s->dataleft = datalen_port_80;
         break;
      case HTONS(81):
         s->dataptr = data_port_81;
         s->dataleft = datalen_port_81;
         break;
      }
      uip_send(s->dataptr, s->dataleft);
      return;      
   }

   if(uip_acked()) {
      if(s->dataleft < uip_mss()) {
         uip_close();
         return;
      }
      s->dataptr += uip_conn->len;
      s->dataleft -= uip_conn->len;
      uip_send(s->dataptr, s->dataleft);      
   }
}
\end{DoxyCode}


\-The application state consists of a pointer to the data that should be sent and the size of the data that is left to send. \-When a remote host connects to the application, the local port number is used to determine which file to send. \-The first chunk of data is sent using uip\-\_\-send(). u\-I\-P makes sure that no more than \-M\-S\-S bytes of data is actually sent, even though s-\/$>$dataleft may be larger than the \-M\-S\-S.

\-The application is driven by incoming acknowledgments. \-When data has been acknowledged, new data can be sent. \-If there is no more data to send, the connection is closed using uip\-\_\-close().\hypertarget{a00060_example6}{}\paragraph{\-Structured Application Program Design}\label{a00060_example6}
\-When writing larger programs using u\-I\-P it is useful to be able to utilize the u\-I\-P \-A\-P\-I in a structured way. \-The following example provides a structured design that has showed itself to be useful for writing larger protocol implementations than the previous examples showed here. \-The program is divided into an u\-I\-P event handler function that calls seven application handler functions that process new data, act on acknowledged data, send new data, deal with connection establishment or closure events and handle errors. \-The functions are called newdata(), acked(), senddata(), connected(), closed(), aborted(), and timedout(), and needs to be written specifically for the protocol that is being implemented.

\-The u\-I\-P event handler function is shown below.


\begin{DoxyCode}
void example6_app(void) {
  if(uip_aborted()) {
    aborted();
  }
  if(uip_timedout()) {
    timedout();
  }
  if(uip_closed()) {
    closed();
  }
  if(uip_connected()) {
    connected();
  }
  if(uip_acked()) {
    acked();
  }
  if(uip_newdata()) {
    newdata();
  }
  if(uip_rexmit() ||
     uip_newdata() ||
     uip_acked() ||
     uip_connected() ||
     uip_poll()) {
    senddata();
  }
}
\end{DoxyCode}


\-The function starts with dealing with any error conditions that might have happened by checking if uip\-\_\-aborted() or uip\-\_\-timedout() are true. \-If so, the appropriate error function is called. \-Also, if the connection has been closed, the closed() function is called to the it deal with the event.

\-Next, the function checks if the connection has just been established by checking if uip\-\_\-connected() is true. \-The connected() function is called and is supposed to do whatever needs to be done when the connection is established, such as intializing the application state for the connection. \-Since it may be the case that data should be sent out, the senddata() function is called to deal with the outgoing data.

\-The following very simple application serves as an example of how the application handler functions might look. \-This application simply waits for any data to arrive on the connection, and responds to the data by sending out the message \char`\"{}\-Hello world!\char`\"{}. \-To illustrate how to develop an application state machine, this message is sent in two parts, first the \char`\"{}\-Hello\char`\"{} part and then the \char`\"{}world!\char`\"{} part.


\begin{DoxyCode}
#define STATE_WAITING 0
#define STATE_HELLO   1
#define STATE_WORLD   2

struct example6_state {
  uint8_t state;
  char *textptr;
  int  textlen;
};

static void aborted(void) {}
static void timedout(void) {}
static void closed(void) {}

static void connected(void) {
  struct example6_state *s = (struct example6_state *)uip_conn->appstate;

  s->state   = STATE_WAITING;
  s->textlen = 0;
}

static void newdata(void) {
  struct example6_state *s = (struct example6_state *)uip_conn->appstate;

  if(s->state == STATE_WAITING) {
    s->state   = STATE_HELLO;
    s->textptr = "Hello ";
    s->textlen = 6;
  }
}

static void acked(void) {
  struct example6_state *s = (struct example6_state *)uip_conn->appstate;
  
  s->textlen -= uip_conn->len;
  s->textptr += uip_conn->len;
  if(s->textlen == 0) {
    switch(s->state) {
    case STATE_HELLO:
      s->state   = STATE_WORLD;
      s->textptr = "world!\n";
      s->textlen = 7;
      break;
    case STATE_WORLD:
      uip_close();
      break;
    }
  }
}

static void senddata(void) {
  struct example6_state *s = (struct example6_state *)uip_conn->appstate;

  if(s->textlen > 0) {
    uip_send(s->textptr, s->textlen);
  }
}
\end{DoxyCode}


\-The application state consists of a \char`\"{}state\char`\"{} variable, a \char`\"{}textptr\char`\"{} pointer to a text message and the \char`\"{}textlen\char`\"{} length of the text message. \-The \char`\"{}state\char`\"{} variable can be either \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-A\-I\-T\-I\-N\-G\char`\"{}, meaning that the application is waiting for data to arrive from the network, \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-H\-E\-L\-L\-O\char`\"{}, in which the application is sending the \char`\"{}\-Hello\char`\"{} part of the message, or \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-O\-R\-L\-D\char`\"{}, in which the application is sending the \char`\"{}world!\char`\"{} message.

\-The application does not handle errors or connection closing events, and therefore the aborted(), timedout() and closed() functions are implemented as empty functions.

\-The connected() function will be called when a connection has been established, and in this case sets the \char`\"{}state\char`\"{} variable to be \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-A\-I\-T\-I\-N\-G\char`\"{} and the \char`\"{}textlen\char`\"{} variable to be zero, indicating that there is no message to be sent out.

\-When new data arrives from the network, the newdata() function will be called by the event handler function. \-The newdata() function will check if the connection is in the \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-A\-I\-T\-I\-N\-G\char`\"{} state, and if so switches to the \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-H\-E\-L\-L\-O\char`\"{} state and registers a 6 byte long \char`\"{}\-Hello
\char`\"{} message with the connection. \-This message will later be sent out by the senddata() function.

\-The acked() function is called whenever data that previously was sent has been acknowleged by the receiving host. \-This acked() function first reduces the amount of data that is left to send, by subtracting the length of the previously sent data (obtained from \char`\"{}uip\-\_\-conn-\/$>$len\char`\"{}) from the \char`\"{}textlen\char`\"{} variable, and also adjusts the \char`\"{}textptr\char`\"{} pointer accordingly. \-It then checks if the \char`\"{}textlen\char`\"{} variable now is zero, which indicates that all data now has been successfully received, and if so changes application state. \-If the application was in the \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-H\-E\-L\-L\-O\char`\"{} state, it switches state to \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-O\-R\-L\-D\char`\"{} and sets up a 7 byte \char`\"{}world!$\backslash$n\char`\"{} message to be sent. \-If the application was in the \char`\"{}\-S\-T\-A\-T\-E\-\_\-\-W\-O\-R\-L\-D\char`\"{} state, it closes the connection.

\-Finally, the senddata() function takes care of actually sending the data that is to be sent. \-It is called by the event handler function when new data has been received, when data has been acknowledged, when a new connection has been established, when the connection is polled because of inactivity, or when a retransmission should be made. \-The purpose of the senddata() function is to optionally format the data that is to be sent, and to call the uip\-\_\-send() function to actually send out the data. \-In this particular example, the function simply calls uip\-\_\-send() with the appropriate arguments if data is to be sent, after checking if data should be sent out or not as indicated by the \char`\"{}textlen\char`\"{} variable.

\-It is important to note that the senddata() function never should affect the application state; this should only be done in the acked() and newdata() functions.\hypertarget{a00060_protoimpl}{}\subsubsection{\-Protocol Implementations}\label{a00060_protoimpl}
\-The protocols in the \-T\-C\-P/\-I\-P protocol suite are designed in a layered fashion where each protocol performs a specific function and the interactions between the protocol layers are strictly defined. \-While the layered approach is a good way to design protocols, it is not always the best way to implement them. \-In u\-I\-P, the protocol implementations are tightly coupled in order to save code space.

\-This section gives detailed information on the specific protocol implementations in u\-I\-P.\hypertarget{a00060_ip}{}\paragraph{\-I\-P -\/-\/-\/ Internet Protocol}\label{a00060_ip}
\-When incoming packets are processed by u\-I\-P, the \-I\-P layer is the first protocol that examines the packet. \-The \-I\-P layer does a few simple checks such as if the destination \-I\-P address of the incoming packet matches any of the local \-I\-P address and verifies the \-I\-P header checksum. \-Since there are no \-I\-P options that are strictly required and because they are very uncommon, any \-I\-P options in received packets are dropped.\hypertarget{a00060_ipreass}{}\subparagraph{\-I\-P Fragment Reassembly}\label{a00060_ipreass}
\-I\-P fragment reassembly is implemented using a separate buffer that holds the packet to be reassembled. \-An incoming fragment is copied into the right place in the buffer and a bit map is used to keep track of which fragments have been received. \-Because the first byte of an \-I\-P fragment is aligned on an 8-\/byte boundary, the bit map requires a small amount of memory. \-When all fragments have been reassembled, the resulting \-I\-P packet is passed to the transport layer. \-If all fragments have not been received within a specified time frame, the packet is dropped.

\-The current implementation only has a single buffer for holding packets to be reassembled, and therefore does not support simultaneous reassembly of more than one packet. \-Since fragmented packets are uncommon, this ought to be a reasonable decision. \-Extending the implementation to support multiple buffers would be straightforward, however.\hypertarget{a00060_ipbroadcast}{}\subparagraph{\-Broadcasts and Multicasts}\label{a00060_ipbroadcast}
\-I\-P has the ability to broadcast and multicast packets on the local network. \-Such packets are addressed to special broadcast and multicast addresses. \-Broadcast is used heavily in many \-U\-D\-P based protocols such as the \-Microsoft \-Windows file-\/sharing \-S\-M\-B protocol. \-Multicast is primarily used in protocols used for multimedia distribution such as \-R\-T\-P. \-T\-C\-P is a point-\/to-\/point protocol and does not use broadcast or multicast packets. u\-I\-P current supports broadcast packets as well as sending multicast packets. \-Joining multicast groups (\-I\-G\-M\-P) and receiving non-\/local multicast packets is not currently supported.\hypertarget{a00060_icmp}{}\paragraph{\-I\-C\-M\-P -\/-\/-\/ Internet Control Message Protocol}\label{a00060_icmp}
\-The \-I\-C\-M\-P protocol is used for reporting soft error conditions and for querying host parameters. \-Its main use is, however, the echo mechanism which is used by the \char`\"{}ping\char`\"{} program.

\-The \-I\-C\-M\-P implementation in u\-I\-P is very simple as itis restricted to only implement \-I\-C\-M\-P echo messages. \-Replies to echo messages are constructed by simply swapping the source and destination \-I\-P addresses of incoming echo requests and rewriting the \-I\-C\-M\-P header with the \-Echo-\/\-Reply message type. \-The \-I\-C\-M\-P checksum is adjusted using standard techniques (see \-R\-F\-C1624).

\-Since only the \-I\-C\-M\-P echo message is implemented, there is no support for \-Path \-M\-T\-U discovery or \-I\-C\-M\-P redirect messages. \-Neither of these is strictly required for interoperability; they are performance enhancement mechanisms.\hypertarget{a00060_tcp}{}\paragraph{\-T\-C\-P -\/-\/-\/ Transmission Control Protocol}\label{a00060_tcp}
\-The \-T\-C\-P implementation in u\-I\-P is driven by incoming packets and timer events. \-Incoming packets are parsed by \-T\-C\-P and if the packet contains data that is to be delivered to the application, the application is invoked by the means of the application function call. \-If the incoming packet acknowledges previously sent data, the connection state is updated and the application is informed, allowing it to send out new data.\hypertarget{a00060_listeb}{}\subparagraph{\-Listening Connections}\label{a00060_listeb}
\-T\-C\-P allows a connection to listen for incoming connection requests. \-In u\-I\-P, a listening connection is identified by the 16-\/bit port number and incoming connection requests are checked against the list of listening connections. \-This list of listening connections is dynamic and can be altered by the applications in the system.\hypertarget{a00060_slidingwindow}{}\subparagraph{\-Sliding Window}\label{a00060_slidingwindow}
\-Most \-T\-C\-P implementations use a sliding window mechanism for sending data. \-Multiple data segments are sent in succession without waiting for an acknowledgment for each segment.

\-The sliding window algorithm uses a lot of 32-\/bit operations and because 32-\/bit arithmetic is fairly expensive on most 8-\/bit \-C\-P\-Us, u\-I\-P does not implement it. \-Also, u\-I\-P does not buffer sent packets and a sliding window implementation that does not buffer sent packets will have to be supported by a complex application layer. \-Instead, u\-I\-P allows only a single \-T\-C\-P segment per connection to be unacknowledged at any given time.

\-It is important to note that even though most \-T\-C\-P implementations use the sliding window algorithm, it is not required by the \-T\-C\-P specifications. \-Removing the sliding window mechanism does not affect interoperability in any way.\hypertarget{a00060_rttest}{}\subparagraph{\-Round-\/\-Trip Time Estimation}\label{a00060_rttest}
\-T\-C\-P continuously estimates the current \-Round-\/\-Trip \-Time (\-R\-T\-T) of every active connection in order to find a suitable value for the retransmission time-\/out.

\-The \-R\-T\-T estimation in u\-I\-P is implemented using \-T\-C\-P's periodic timer. \-Each time the periodic timer fires, it increments a counter for each connection that has unacknowledged data in the network. \-When an acknowledgment is received, the current value of the counter is used as a sample of the \-R\-T\-T. \-The sample is used together with \-Van \-Jacobson's standard \-T\-C\-P \-R\-T\-T estimation function to calculate an estimate of the \-R\-T\-T. \-Karn's algorithm is used to ensure that retransmissions do not skew the estimates.\hypertarget{a00060_rexmit}{}\subparagraph{\-Retransmissions}\label{a00060_rexmit}
\-Retransmissions are driven by the periodic \-T\-C\-P timer. \-Every time the periodic timer is invoked, the retransmission timer for each connection is decremented. \-If the timer reaches zero, a retransmission should be made.

\-As u\-I\-P does not keep track of packet contents after they have been sent by the device driver, u\-I\-P requires that the application takes an active part in performing the retransmission. \-When u\-I\-P decides that a segment should be retransmitted, it calls the application with a flag set indicating that a retransmission is required. \-The application checks the retransmission flag and produces the same data that was previously sent. \-From the application's standpoint, performing a retransmission is not different from how the data originally was sent. \-Therefore the application can be written in such a way that the same code is used both for sending data and retransmitting data. \-Also, it is important to note that even though the actual retransmission operation is carried out by the application, it is the responsibility of the stack to know when the retransmission should be made. \-Thus the complexity of the application does not necessarily increase because it takes an active part in doing retransmissions.\hypertarget{a00060_flowcontrol}{}\subparagraph{\-Flow Control}\label{a00060_flowcontrol}
\-The purpose of \-T\-C\-P's flow control mechanisms is to allow communication between hosts with wildly varying memory dimensions. \-In each \-T\-C\-P segment, the sender of the segment indicates its available buffer space. \-A \-T\-C\-P sender must not send more data than the buffer space indicated by the receiver.

\-In u\-I\-P, the application cannot send more data than the receiving host can buffer. \-And application cannot send more data than the amount of bytes it is allowed to send by the receiving host. \-If the remote host cannot accept any data at all, the stack initiates the zero window probing mechanism.\hypertarget{a00060_congestioncontrol}{}\subparagraph{\-Congestion Control}\label{a00060_congestioncontrol}
\-The congestion control mechanisms limit the number of simultaneous \-T\-C\-P segments in the network. \-The algorithms used for congestion control are designed to be simple to implement and require only a few lines of code.

\-Since u\-I\-P only handles one in-\/flight \-T\-C\-P segment per connection, the amount of simultaneous segments cannot be further limited, thus the congestion control mechanisms are not needed.\hypertarget{a00060_urgdata}{}\subparagraph{\-Urgent Data}\label{a00060_urgdata}
\-T\-C\-P's urgent data mechanism provides an application-\/to-\/application notification mechanism, which can be used by an application to mark parts of the data stream as being more urgent than the normal stream. \-It is up to the receiving application to interpret the meaning of the urgent data.

\-In many \-T\-C\-P implementations, including the \-B\-S\-D implementation, the urgent data feature increases the complexity of the implementation because it requires an asynchronous notification mechanism in an otherwise synchronous \-A\-P\-I. \-As u\-I\-P already use an asynchronous event based \-A\-P\-I, the implementation of the urgent data feature does not lead to increased complexity.\hypertarget{a00060_performance}{}\subsubsection{\-Performance}\label{a00060_performance}
\-In \-T\-C\-P/\-I\-P implementations for high-\/end systems, processing time is dominated by the checksum calculation loop, the operation of copying packet data and context switching. \-Operating systems for high-\/end systems often have multiple protection domains for protecting kernel data from user processes and user processes from each other. \-Because the \-T\-C\-P/\-I\-P stack is run in the kernel, data has to be copied between the kernel space and the address space of the user processes and a context switch has to be performed once the data has been copied. \-Performance can be enhanced by combining the copy operation with the checksum calculation. \-Because high-\/end systems usually have numerous active connections, packet demultiplexing is also an expensive operation.

\-A small embedded device does not have the necessary processing power to have multiple protection domains and the power to run a multitasking operating system. \-Therefore there is no need to copy data between the \-T\-C\-P/\-I\-P stack and the application program. \-With an event based \-A\-P\-I there is no context switch between the \-T\-C\-P/\-I\-P stack and the applications.

\-In such limited systems, the \-T\-C\-P/\-I\-P processing overhead is dominated by the copying of packet data from the network device to host memory, and checksum calculation. \-Apart from the checksum calculation and copying, the \-T\-C\-P processing done for an incoming packet involves only updating a few counters and flags before handing the data over to the application. \-Thus an estimate of the \-C\-P\-U overhead of our \-T\-C\-P/\-I\-P implementations can be obtained by calculating the amount of \-C\-P\-U cycles needed for the checksum calculation and copying of a maximum sized packet.\hypertarget{a00060_delack}{}\paragraph{\-The Impact of Delayed Acknowledgments}\label{a00060_delack}
\-Most \-T\-C\-P receivers implement the delayed acknowledgment algorithm for reducing the number of pure acknowledgment packets sent. \-A \-T\-C\-P receiver using this algorithm will only send acknowledgments for every other received segment. \-If no segment is received within a specific time-\/frame, an acknowledgment is sent. \-The time-\/frame can be as high as 500 ms but typically is 200 ms.

\-A \-T\-C\-P sender such as u\-I\-P that only handles a single outstanding \-T\-C\-P segment will interact poorly with the delayed acknowledgment algorithm. \-Because the receiver only receives a single segment at a time, it will wait as much as 500 ms before an acknowledgment is sent. \-This means that the maximum possible throughput is severely limited by the 500 ms idle time.

\-Thus the maximum throughput equation when sending data from u\-I\-P will be \$p = s / (t + t\-\_\-d)\$ where \$s\$ is the segment size and \$t\-\_\-d\$ is the delayed acknowledgment timeout, which typically is between 200 and 500 ms. \-With a segment size of 1000 bytes, a round-\/trip time of 40 ms and a delayed acknowledgment timeout of 200 ms, the maximum throughput will be 4166 bytes per second. \-With the delayed acknowledgment algorithm disabled at the receiver, the maximum throughput would be 25000 bytes per second.

\-It should be noted, however, that since small systems running u\-I\-P are not very likely to have large amounts of data to send, the delayed acknowledgmen t throughput degradation of u\-I\-P need not be very severe. \-Small amounts of data sent by such a system will not span more than a single \-T\-C\-P segment, and would therefore not be affected by the throughput degradation anyway.

\-The maximum throughput when u\-I\-P acts as a receiver is not affected by the delayed acknowledgment throughput degradation.

\begin{DoxyNote}{\-Note}
\-The uipsplit module implements a hack that overcomes the problems with the delayed acknowledgment throughput degradation. 
\end{DoxyNote}
